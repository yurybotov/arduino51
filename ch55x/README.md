### Сейчас эта библиотека не работоспособна (что то с USB Serial)

## О ch55x

Есть серия недорогих 51 контроллеров от производителя WCH известного своим USB to Serial ch340, и они отличаются от других наличием встроенной поддержки USB. 

ch559 - многоножка, 64к FLASH, умеет быть USB хостом и USB девайсом. Хост/девайс ch554 и девайс ch552 - в корпусе как у ch340, 16к FLASH. И младший братишка в таком же корпусе ch551 - 10к FLASH, USB девайс.

Самое прикольное что им не нужен внешний программатор, они программируются прямо по USB. Для этого необходимо притянуть P3.6/UDP через резистор 10к ноге V33 (это **выход** питания!). В программаторе есть

## Реализация

Библиотека подразумевает работу контроллера от встроенного генератора без внешнего кварца с частотой 24 MHz. Параметры памяти настроены на **ch552** или **ch554**.

### Пины

**Поскольку пины микросхемы никак не связаны с со стандартными раскладками плат Ардуино, пришлось использовать альтернативное наименование для них. Так для цифровых пинов используется вид `D{номер порта}{номер бита}`, для работы пина как аналогового входа `A{номер порта}{номер бита}`, а для работы в качестве аналогового выхода (ШИМ) `PWM{номер порта}{номер бита}`.**

Поддерживаются функции:

`void pinMode(byte PIN, byte mode)` - установить режим пина, `mode` может иметь значения:

`INPUT` - вход с высоким импедансом

`OUTPUT` - аналог PUSHPULL

`PUSHPULL` - выход с двухтактным каскадом

`BIDIRECTIONAL` - стандартный для x51 вариант: выход без подтяжки, при записи в него единицы можно использовать его как вход

`byte digitalRead(byte PIN)` - прочитать значение пина (0/1), читается не то что было записано в порт, а реальное состояние вывода

`void digitalWrite(byte PIN, byte value)` - записать значение `value` (0/1) в пин

Как и в Ардуино можно использовать как значение:

`HIGH` = 1

`LOW` = 0

`word analogRead(byte PIN)` - прочитать аналоговое значение с ADC. Естественно это возможно только на тех ногах на которых он доступен: `A11, A14, A15, A32`. Необходимо предварительно использовать `pinMode(Axx,INPUT)`. Диапазон преобразования [0...Vcc] -> `[0..255]`.

`void analogWrite(byte PIN, word value)` - установить значение PWM. Допустимо только для тех ног которые поддерживают PWM: `PWM14, PWM30, PWM34, PWM31`. Важно: число каналов PWM меньше чем число выводов, некоторые выводы нельзя использовать для PWM одновременно: PWM14 и PWM30, PWM34 и PWM31. Для инициализации необходимо использовать `pinMode(PWMxx, OUTPUT)`. Частота PWM установлена примерно в `2кГц`, диапазон уровней `[0..255]` -> [0..Vcc].

### Функции времени

Библиотека использует `Timer0` для `delay()`, `millis()`, `micros()` и других функций связанных с временем. Минимальный квант времени 10 мкс. `Timer1` используется для работы `UART0 (Serial0)`, а у `UART1 (Serial1)` есть собственный таймер. `Timer2` - свободен.

Итак поддерживаются:

`dword millis()` - возвращает системное время в миллисекундах

dword micros() - не реализована, поскольку частые прерывания таймера мешают нормальной работе CDC USB Serial 

`void delay(dword time)` - останавливает выполнение программы на time миллисекунд

void delayMicroseconds(dword time) - не реализована по упомянутой выше причине

`dword pulseIn(byte pin, bool value, dword timeOut)` - возвращает "ширину импульса" в миллисекундах - от начала своего выполнения до момента когда пин pin примет значение value. Если это не произошло за время timeOut возвращает время timeOut. Вариант функции без timeOut не реализован.  

### Serial

Имеются `Serial0` и `Serial1` на UART0 и UART1 соответственно. Кроме того есть `Serial` - это USB CDC устройство. Передача ведется синхронно, прием ассинхронно, по прерыванию данные помещаются в буфер.

**Важно! У всех Serial и у I2C мастер - общий приемный буфер. По умолчанию 128 байт на всех. Идея это достаточно дурацкая, но пока себя оправдывает.**

Максимальная поддерживаемая скорость передачи через `Serial0` - `57600`, через `Serial1` - `115200` и вообще точность устанавливаемой скорости у Serial1 выше. Для `Serial` - устанавливаемая скорость значения не имеет. Чтобы использовать большие скорости на UART0 нужно использовать внешний кварц на 16600 МГц - это не реализовано.

Итак поддерживаются (символ X соответствует пробелу, 1 или 2 в зависимости от того какой порт используется):

`void SerialXBegin(dword speed)` - инициализирует UART с указанной скоростью передачи

`void SerialXPutc(byte c)` - посылает байт

`void SerialXPrintf(const byte* format,...)` - посылает форматированную строку, например: `SerialXPrintf("строка формата %d 0x%x\n", var1, var2);`. Поддерживаются модификаторы `%d` - десятичное целое, `%x` - шестнадцатеричное, `%o` - восьмиричное, `%c` - символ, `%s` - строка. Для 8 битных чисел при передаче в строку параметров преобразуйте их к 16 битным - `(int)var8bit`. Для 32 битных чисел есть соответствующие модификаторы: `%ld`,`%lx`,`lo`. Строка может выводится просто как `SerialPrint("строка\n");`. Старайтесь не передавать в `SerialXPrintf` много параметров, стэк в контроллере невелик, лучше вызовите функцию несколько раз.

`byte SerialXRead(void)` - принимает байт (на самом деле достает его из буфера). Всегда проверяйте наличие в буфере прежде чем читать. Если там пусто получите `0`.

`byte SerialXAvailable(void)` - проверяет наличие данных в буфере (возвращает количество ожидающих байт)

### I2C


**Важно! У всех Serial и у I2C мастер - общий приемный буфер. По умолчанию 128 байт на всех. Идея это достаточно дурацкая, но пока себя оправдывает.**

пока не работает

### SPI

пока не работает

### Разные разности

Как и в Ардуино используется ряд общеупотребимых макросов. Необходимо пользоваться ими с осторожностью, не передавая им в качестве параметров выражения.

`bit(b)` - возвращает байт/слово/двойное слово в котором бит с номером `b` установлен в 1 а остальные 0

`bitClear(x, b)` - записывает 0 в бит с номером `b` в переменную `x`

`bitSet(x, b)` - записывает 1 в бит с номером `b` в переменную `x`

`bitRead(x, b)` - возвращает значение бита с номером `b` из переменной `x`

`bitWrite(x, b, v)` - записывает значение `v` в бит с номером `b` в переменную `x`

`highByte(w)` - возвращает старший байт слова

`lowByte(w)` - возвращает младший байт слова

`abs(x)` -  убирает знак числа

`constrain(v, min, max)` - обрезает число `v` до значения граничного, если оно выходит за границы `min` или `max`

`max(x, y)` - возвращает максимальное из 2 значений

`min(x, y)`- возвращает минимальное из 2 значений

`map(x, in_min, in_max, out_min, out_max)` - пересчитывает значение из одного диапазона в другой

`sq(x)` - возвращает квадрат числа 

## Примеры

### Blink

```c
#include "arduino.h"

void setup() {
    pinMode(D15,OUTPUT);
}

void loop() {
    digitalWrite(D15,HIGH);
    delay(1000);

    digitalWrite(D15,LOW);
    delay(1000);
}
```

### Analog read to CDC Serial

```c
#include "arduino.h"

void setup() {
    pinMode(A11,INPUT);
    SerialBegin(9600);
}

void loop() {
    SerialPrintf("A11 = %d\n", analogRead(A11));
    delay(1000);
}
```

### Analog to PWM

```c
#include "arduino.h"

void setup() {
    pinMode(A11,INPUT);
    pinMode(PWM14,OUTPUT);
}

void loop() {
    analogWrite(PWM14,analogRead(A11));
    delay(10);
}
```
