## arduino51

Иногда хочется по быстрому что то опробовать на контроллере, но знаний как у ардуинщика, а контроллер какой-то экзотический, например копеечный китайский однотактовый 8051. Вот для этого и сделана данная библиотечка.

## Поддерживает

- Nuvoton N76E003
- WCH.CN ch551, ch552, ch554, ch559 (частично)

## Как этим пользоваться?

Для начала поставить SDCC, make и binutils. Да, под Windows я пишу в vs-code, компилировать перехожу в окошечко bash (ubuntu) - там вызываю `make`, потом полученную прошивку заливаю из программатора под Windows. Так что `SDCC`, `make` и `binutils` надо поставить в линуксе. Ну и `mc` тоже не повредит. А под Windows надо поставить программатор (ищи в папке `extra`, ну или на сайтах производителя чипов - они взяты оттуда).

Копируйте папку с именем чипа (и заодно папку `common`) к себе. 

В папке есть файл по имени `sketch.c` - это тот файл который вы и будете наполнять своим кодом. В нем обычные функции `setup` и `loop`.
Кроме того есть файлы `Makefile` и `Makefile.include`. Если нужно подключить дополнительные `c` файлы с кодом - добавьте их в список в файле `Makefile`.

Библиотечка лежит в папке `lib`. По умолчанию она подключена вся. Есть еще общая часть кода для всех контроллеров она находится в `common` Подробности в README в соответствующих чипам папках.


## Отличия от ардуино

Естественно синтаксис не совсем ардуиновский, поскольку SDCC это компилятор `С` и с++ он не понимает. По сему - никаких классов, все переменные в функции должны быть объявлены до начала вычислений, и самый мой любимый косяк компилятора - все объявления обработчиков прерывания обязательно должны быть указаны в файле в котором лежит main(). То есть:

- Serial.begin() -> `SerialBegin()`

- for(int i = 0;...) -> `int i; for(i = 0;...)`

- и так далее.

Поскольку С не поддерживает функций с одним именем и различными типами параметров, `Serial.print()` пришлось заменить на  `SerialPrintf("format line %d", var)`.

Поскольку у микросхем нет привязки к конкретным pin ардуино, мне пришлось обращаться к ним в зависимости от номера порта. Так вывод `D14` это доступ к 4 биту порта 1.

- `pinMode(D14,OUTPUT);`

- `pinMode(D11,ADC);`

- `pinMode(D15,PWM);`

- `a = digitalRead(D14);`

- `b = analogRead(D12);`

К слову, режимы отличаются от ардуино: `BIDIRECTIONAL,OUTPUT==PUSHPULL,INPUT,ADC,PWM`

Есть и специфические вещи связанные с x51 контроллером. Вы быстро столкнетесь с тем что "не хватает озу". На самом деле хватает, но их у контроллера 3: __data, __idata и __xdata и они отличаются размерами. Так что компилятору нужно подсказать что надо использовать не память по умолчанию __data, какую то другую. Перед любыми массивами можно смело ставить префикс __xdata.
