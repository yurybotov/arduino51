## О STC stc8f2k16s2

Китайцам не дает покоя stm8f003 и это еще одна попытка его клонировать на x51 однотактовом ядре. Вернее не это его клон, полный клон называется у них (STC) gx8s003. Но это тоже нечто схожее, в том же 20-ногом корпусе. Это тоже простой x51 копеечный микроконтроллер. В папке extra можно найти программатор под windows (можете поискать более свежий на сайте производителя), даташит (ищите семейство sct8f2k64s2 - это он, кстати именно это семейство представлено в даташите нескольким очень крупными ляпами, так что осторожнее).

В отличие от stm8s003 имеет второй UART, лишнюю свободную ногу (можно считать даже 2), в 2 раза больше FLASH, больший EEPROM, больше RAM, однако абсолютно не приспособлен для работы с аналоговыми сигналами... ни ADC ни PWM нет. Врочем компаратор есть. (И да, у полного клона - gx8s003 - все это есть).

- 16 кБайт FLASH, плюс 4 кБайт EEPROM

- 2304 байт RAM, из них 256 байт стандартная память i51, а 2048 байта - типа внешняя

- тактовая частота 24 МГц без внешнего кварца (задается "фьюзами" при прошивке), при внешнем кварце может и 28 мГц.

- 18 ног для использования (считая Reset который можно назначить просто портом)

- 3 стандартных x51 таймера T0,T1,T2 плюс T3,T4 - копии T2 итого 5 штук.

- 2 UART, стандартные x51

- есть SPI до 8 МГц

- есть I2C

- питается от 2.5...5.5 вольт. Выводы толерантны к 5В.

- прерывания, браун-оут, вэйк-ап, вотч-дог, и так далее

- минимальная обвеска при подключении: конденсаторы по питанию.

Прошивается с помощью любого USB-Serial, добавочно желательно прицепить диод и резистор по схеме из даташита, впрочем можно и без них. Процесс програмирования несколько мудреный: выбрать файл, нажать "Download/Program", после чего выключить/включить ПИТАНИЕ контроллера. В общем пользоваться можно. Есть возможность программирования и вообще без USB-Serial - напямую от USB, однако надо установить на винду драйвер медленного сериала от производителя, а он собака, не подписанный. Я не стал заморачиваться.

## Реализация

Библиотека подразумевает работу контроллера от встроенного генератора без внешнего кварца с частотой 24MHz.


### Пины

**Поскольку пины микросхемы никак не связаны с со стандартными раскладками плат Ардуино, пришлось использовать альтернативное наименование для них. Так для пинов используется вид `D{номер порта}{номер бита}`.**

Поддерживаются функции:

`void pinMode(byte PIN, byte mode)` - установить режим пина, `mode` может иметь значения:

`INPUT` - вход с высоким импедансом

`OUTPUT` - аналог PUSHPULL

`PUSHPULL` - выход с двухтактным каскадом

`BIDIRECTIONAL` - стандартный для x51 вариант: выход без подтяжки, при записи в него единицы можно использовать его как вход

`OPENDRAIN` - выход "с открытым стоком", без подтяжки к питанию

`byte digitalRead(byte PIN)` - прочитать значение пина (0/1), читается не то что было записано в порт, а реальное состояние вывода

`void digitalWrite(byte PIN, byte value)` - записать значение `value` (0/1) в пин

Как и в Ардуино можно использовать как значение:

`HIGH` = 1

`LOW` = 0


### Прерывания на пинах


### Функции времени

Библиотека использует `Timer0` для `delay()`, `millis()`, `micros()` и других функций связанных с временем. Минимальный квант времени 10 мкс. `Timer1` используется для работы `UART1 (Serial1)`, а `Timer3` для `UART1 (Serial1)`. `Timer2` - свободен. ????

Итак поддерживаются:

`dword millis()` - возвращает системное время в миллисекундах

`dword micros()` - возвращает системное время в микросекундах (с шагом 10 микросекунд) 

`void delay(dword time)` - останавливает выполнение программы на time миллисекунд

`void delayMicroseconds(dword time)` - останавливает выполнение на time микросекунд

`dword pulseIn(byte pin, bool value, dword timeOut)` - возвращает "ширину импульса" в миллисекундах - от начала своего выполнения до момента когда пин pin примет значение value. Если это не произошло за время timeOut возвращает время timeOut. Вариант функции без timeOut не реализован.  


### Serial


### I2C


### SPI


### EEPROM


### Разные разности

Как и в Ардуино используется ряд общеупотребимых макросов. Необходимо пользоваться ими с осторожностью, не передавая им в качестве параметров выражения.

`bit(b)` - возвращает байт/слово/двойное слово в котором бит с номером `b` установлен в 1 а остальные 0

`bitClear(x, b)` - записывает 0 в бит с номером `b` в переменную `x`

`bitSet(x, b)` - записывает 1 в бит с номером `b` в переменную `x`

`bitRead(x, b)` - возвращает значение бита с номером `b` из переменной `x`

`bitWrite(x, b, v)` - записывает значение `v` в бит с номером `b` в переменную `x`

`highByte(w)` - возвращает старший байт слова

`lowByte(w)` - возвращает младший байт слова

`abs(x)` -  убирает знак числа

`constrain(v, min, max)` - обрезает число `v` до значения граничного, если оно выходит за границы `min` или `max`

`max(x, y)` - возвращает максимальное из 2 значений

`min(x, y)`- возвращает минимальное из 2 значений

`map(x, in_min, in_max, out_min, out_max)` - пересчитывает значение из одного диапазона в другой

`sq(x)` - возвращает квадрат числа 


## Примеры


### Blink

```c
#include "arduino.h"

void setup() {
    pinMode(D37,OUTPUT);
}

void loop() {
    digitalWrite(D37,HIGH);
    delay(1000);

    digitalWrite(D37,LOW);
    delay(1000);
}
```

### Serial0 "Hello World"

```c
#include "arduino.h"

void setup() {
    Serial0Begin(9600);
}

void loop() {
    Serial0Printf("Hello World!\n");
    delay(1000);
}
```

### I2C read from 24c04 EEPROM

```c
#include "arduino.h"

void setup() {    
    Serial0Begin(19200);
    I2CBeginMaster();
    I2CSetClock(I2C_FAST);
}

void loop() {
    I2CBeginTransmission(0x50); // 24c04 address 0x50
    I2CWrite(0);                // read from 0 address
    I2CWrite(0);                //
    I2CRequestFrom(0x50, 32, 1); // read 32 bytes to buffer and close
    I2CEndTransmission();
    while(I2CAvailable()) {     // if i2c data exists in buffer
        Serial0Printf("%c",I2CRead()); // print it
    }
    Serial0Putc('\n');
    delay(1000);
}
```

## Pceudo EEPROM read/write

```c
#include "arduino.h"

dword next;

void setup() {   
    Serial0Begin(19200);
    next = millis() + 500;
}

void loop() {
    if(next < millis()) {
        next = millis() + 500;
        EEPROMWrite(0,'A');
        EEPROMWrite(1,'b');
        EEPROMWrite(2,'c');
        EEPROMWrite(1,'B');
        Serial0Printf("%c%c%c\n",EEPROMRead(0),EEPROMRead(1),EEPROMRead(2));
    }
}
```

## Pin interrupt

```c
#include "arduino.h"

byte state = 0;

void change(void) {
    state = (~state) & 1;
    digitalWrite(D14, state);
}

void setup() {
    pinMode(D14, OUTPUT);
    digitalWrite(D14, state);
    attachInterrupt(D15, change, RISING_EDGE);
}

void loop() {
}
```
